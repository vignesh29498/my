import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.neighbors import KNeighborsClassifier
import numpy as np

# Load the dataset
data = pd.read_csv('sample_dataset.csv', header=None)

# Transpose the data to have a consistent format
data = data.transpose()
data.columns = data.iloc[0]
data = data[1:]

# Melt the dataframe to have a long format
data = data.melt(var_name='Label', value_name='Value')

# Remove NaN values
data = data.dropna()

# Separate data by labels
label_groups = data.groupby('Label')

models = {}
label_encodings = {}
inverse_label_encodings = {}

# Train a KNN model for each label type
for label, group in label_groups:
    values = group['Value'].values.reshape(-1, 1)
    
    # Convert values to categorical if needed (this assumes values are already suitable for model input)
    value_dict = {val[0]: i for i, val in enumerate(np.unique(values))}
    inverse_value_dict = {i: val[0] for val, i in value_dict.items()}
    
    categorical_values = np.array([value_dict[val[0]] for val in values])
    
    # Encode labels
    label_encodings[label] = value_dict
    inverse_label_encodings[label] = inverse_value_dict
    
    # Train-test split
    X_train, X_val, y_train, y_val = train_test_split(values, categorical_values, test_size=0.2, random_state=42)
    
    # Train the model
    knn = KNeighborsClassifier(n_neighbors=1)  # Using 1 neighbor for exact matching
    knn.fit(X_train, y_train)
    
    models[label] = knn

# Function to predict labels for each value in the list
def predict_labels(input_list):
    predictions = []
    for idx, value in enumerate(input_list):
        found = False
        for label, model in models.items():
            value_array = np.array([[value]])
            try:
                predicted_index = model.predict(value_array)[0]
                predicted_label = inverse_label_encodings[label][predicted_index]
                predictions.append((idx, label))
                found = True
                break
            except:
                continue
        if not found:
            predictions.append((idx, 'Unknown'))
    return predictions

# Example usage
input_list = ['655', 'ml', '086', 'gjke']
predicted_labels_with_positions = predict_labels(input_list)

for idx, label in predicted_labels_with_positions:
    print(f'Position {idx}: Predicted label is {label}')
